<!-- GroupNotesScript.html -->

<script>
(() => {
  if (window.__OFY_groupNotesInitialized) return;
  window.__OFY_groupNotesInitialized = true;

  const GROUP_ORDER = ['Bears','Bulls','Cubs','Fire','Soxs','Stars'];
  let ALL_MENTORS = [];
  const utils = window.ClientUtils || {};
  const fallbackRunner = () => (window.google && google.script && google.script.run) ? google.script.run : null;
  const baseRunner = typeof utils.getRunner === 'function' ? utils.getRunner : fallbackRunner;
  const runner = () => baseRunner();
  const esc = typeof utils.esc === 'function'
    ? (value) => utils.esc(value)
    : (s => String(s || '').replace(/[&<>"']/g, c => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[c])));
  const setStatus = utils.createStatusSetter
    ? utils.createStatusSetter('status')
    : function(msg, tone = 'info'){
        const el = document.getElementById('status');
        if (!el) return;
        if (!msg){
          el.textContent = '';
          el.dataset.state = 'info';
          el.setAttribute('hidden','');
          return;
        }
        const kind = tone === 'bad' ? 'bad' : tone === 'ok' ? 'ok' : 'info';
        el.textContent = msg;
        el.dataset.state = kind;
        el.removeAttribute('hidden');
      };
  const callServer = typeof utils.call === 'function'
    ? (method, args = [], options) => utils.call(method, args, options)
    : (method, args = [], { onSuccess, onFailure } = {}) => {
        const runner = baseRunner();
        if (!runner || typeof runner[method] !== 'function') {
          const err = new Error('Apps Script not available');
          if (typeof onFailure === 'function') {
            try { onFailure(err); } catch (_) {}
          }
          return Promise.reject(err);
        }
        const argArray = Array.isArray(args) ? args : [args];
        return new Promise((resolve, reject) => {
          const proxy = runner
            .withSuccessHandler(res => {
              if (typeof onSuccess === 'function') {
                try { onSuccess(res); } catch (_) {}
              }
              resolve(res);
            })
            .withFailureHandler(err => {
              if (typeof onFailure === 'function') {
                try { onFailure(err); } catch (_) {}
              }
              reject(err);
            });
          try {
            proxy[method](...argArray);
          } catch (err) {
            if (typeof onFailure === 'function') {
              try { onFailure(err); } catch (_) {}
            }
            reject(err);
          }
        });
      };

  // ---- Show any JS error in the UI
  window.addEventListener('error', (e) => {
    const msg = (e?.error?.message || e?.message || 'Unknown error');
    setStatus('Error: ' + msg, 'bad');
    console.error('Uncaught error:', e?.error || e);
  });

  // ---------- Utilities ----------
  function asBool(x) {
    if (x === true || x === false) return x;
    const s = (x == null ? '' : String(x)).trim().toLowerCase();
    if (['true','t','yes','y','1','✓','done','complete','completed'].includes(s)) return true;
    if (['false','f','no','n','0'].includes(s)) return false;
    return null;
  }

  // ---------- Promise wrappers ----------
  function loadMentorsAsync(activeOnly = true){
    return callServer('getMentors', [activeOnly])
      .then(list => {
        ALL_MENTORS = Array.isArray(list) ? list : [];
        return ALL_MENTORS;
      })
      .catch(err => {
        console.warn('getMentors failed:', err);
        ALL_MENTORS = [];
        return ALL_MENTORS;
      });
  }
  function getRosterByDateAsync(dateStr){
    return callServer('getRosterByDate', [dateStr])
      .catch(err => {
        setStatus('Server error: ' + (err?.message || err), 'bad');
        return {};
      });
  }
  async function ensureMentorsLoaded(){
    if (!Array.isArray(ALL_MENTORS) || ALL_MENTORS.length === 0){
      await loadMentorsAsync(true);
    }
    return ALL_MENTORS;
  }

  // ---------- Status logic ----------
  function computeStatus(p) {
    const inDbOk = asBool(p.inDb) === true;
    if (!inDbOk) return { color: 'bad', label: 'Not in DB', missing: ['Not in DB'] };
    const missing = [];
    if (asBool(p.consent) !== true && p.consent !== undefined) missing.push('Consent form');
    if (asBool(p.pre) !== true && p.pre !== undefined)         missing.push('Manbox Pre-test');
    if (missing.length === 0) return { color: 'ok', label: 'All set', missing: [] };
    return { color: 'warn', label: 'Needs items', missing };
  }

  function renderSummary(roster){
    const stats = { participants: 0, ready: 0, needs: 0, noDb: 0 };
    const sets = Object.values(roster || {});
    let activeGroups = 0;
    sets.forEach(list => {
      if (!Array.isArray(list)) return;
      if (list.length) activeGroups += 1;
      list.forEach(person => {
        stats.participants += 1;
        const status = computeStatus(person);
        if (status.color === 'ok') stats.ready += 1;
        else if (status.color === 'warn') stats.needs += 1;
        else if (status.color === 'bad') stats.noDb += 1;
      });
    });
    const assign = (id, value) => {
      const el = document.getElementById(id);
      if (el) el.textContent = Number(value || 0).toLocaleString();
    };
    assign('statParticipants', stats.participants);
    assign('statReady', stats.ready);
    assign('statNeeds', stats.needs);
    assign('statNoDb', stats.noDb);

    const foot = document.getElementById('statGroupsFootnote');
    if (foot) {
      foot.textContent = activeGroups
        ? `Across ${activeGroups} group${activeGroups === 1 ? '' : 's'}`
        : 'Across active groups';
    }
  }

  // ---------- DnD ----------
  function onDragStart(e) {
    const card = e.currentTarget;
    e.dataTransfer.setData('text/plain', JSON.stringify({ id: card.dataset.id, fromGroup: card.dataset.group }));
    e.dataTransfer.dropEffect = 'move';
    card._dragging = true;
  }
  function onDragEnd(e) { e.currentTarget._dragging = false; }
  function onDragOver(e) { e.preventDefault(); e.currentTarget.classList.add('dragover'); }
  function onDragLeave(e) { e.currentTarget.classList.remove('dragover'); }
  function onDropGroup(e) {
    e.preventDefault(); e.currentTarget.classList.remove('dragover');
    const col = e.currentTarget, toGroup = col.dataset.group;
    let payload; try { payload = JSON.parse(e.dataTransfer.getData('text/plain')); } catch (_) {}
    if (!payload?.id || !payload?.fromGroup || !toGroup || payload.fromGroup === toGroup) return;

    const dateStr = document.getElementById('datePicker').value;
    const card = document.querySelector(`.card[data-id="${payload.id}"][data-group="${payload.fromGroup}"]`);
    if (!card) return;
    const originalParent = card.parentElement;

    // Optimistic UI
    card.dataset.group = toGroup;
    col.querySelector('.cards').appendChild(card);

    callServer('moveMember', [payload.id, payload.fromGroup, toGroup, dateStr])
      .then(res => {
        if (!res?.ok) {
          originalParent.appendChild(card);
          card.dataset.group = payload.fromGroup;
          setStatus(res?.error || 'Move failed.', 'bad');
        } else {
          setStatus(`Moved ${card.dataset.name || payload.id} to ${toGroup}.`, 'ok');
        }
      })
      .catch(err => {
        originalParent.appendChild(card);
        card.dataset.group = payload.fromGroup;
        setStatus('Server error: ' + (err?.message || err), 'bad');
      });
  }

  // ---------- Details modal ----------
  function openDetailModal(person, status) {
    const m = document.getElementById('detailModal');
    const title = document.getElementById('modalTitle');
    const body = document.getElementById('modalBody');
    title.textContent = `${person.name} (${person.id})`;
    if (status.color === 'bad') {
      body.innerHTML = `<p><strong>Status:</strong> Not in DB</p><ul><li>Need to complete an intake form</li></ul>`;
    } else if (status.missing.length) {
      body.innerHTML = `<p><strong>Missing items:</strong></p><ul>${status.missing.map(x => `<li>${esc(x)}</li>`).join('')}</ul>`;
    } else {
      body.innerHTML = `<p>All required items are complete ✅</p>`;
    }
    m.style.display = 'flex';
  }
  (function wireDetailModal(){
    const m = document.getElementById('detailModal');
    if (!m) return;
    document.getElementById('modalClose')?.addEventListener('click', () => m.style.display = 'none');
    m.addEventListener('click', (e) => { if (e.target === m) m.style.display = 'none'; });
  })();

  // ---------- Mentors picker ----------
  function wireMentorPicker(noteEl){
    const chipsEl = noteEl.querySelector('.chips');
    const input   = noteEl.querySelector('.mentor-input');
    const sugg    = noteEl.querySelector('.suggestions');

    const selected = noteEl._selectedMentors || (noteEl._selectedMentors = []);
    let pendingMerge = []; // Remember server-provided mentors for name hydration
    const mentorsReady = ensureMentorsLoaded().catch(err => {
      console.warn('Mentor preload failed:', err);
      return [];
    });

    function renderChips(){
      chipsEl.innerHTML = '';
      selected.forEach(m => {
        const chip = document.createElement('span');
        chip.className = 'chip';
        chip.textContent = m.name || m.id;
        const removeBtn = document.createElement('button');
        removeBtn.type = 'button';
        removeBtn.title = 'Remove';
        removeBtn.setAttribute('aria-label', 'Remove mentor');
        removeBtn.textContent = '×';
        removeBtn.addEventListener('click', () => {
          const idx = selected.findIndex(x => String(x.id||'').toUpperCase() === String(m.id||'').toUpperCase());
          if (idx >= 0) selected.splice(idx,1);
          renderChips();
        });
        chip.appendChild(removeBtn);
        chipsEl.appendChild(chip);
      });
    }
    noteEl._renderChips = renderChips;

    function mergeMentorList(list, remember = true){
      const normalized = Array.isArray(list)
        ? list
            .map(m => ({
              id: String(m?.id || '').trim().toUpperCase(),
              name: String(m?.name || '').trim()
            }))
            .filter(m => m.id)
        : [];
      if (remember) pendingMerge = normalized;
      normalized.forEach(item => {
        const existing = selected.find(x => String(x.id||'').toUpperCase() === item.id);
        let name = item.name;
        if (!name) {
          const match = ALL_MENTORS.find(x => String(x.id||'').trim().toUpperCase() === item.id);
          name = match?.name || item.id;
        }
        if (existing) {
          if (!existing.name || existing.name === existing.id) existing.name = name;
        } else {
          selected.push({ id: item.id, name });
        }
      });
      renderChips();
    }

    function closeSuggestions(){ sugg.classList.remove('open'); sugg.innerHTML=''; }
    function openSuggestions(items){
      sugg.classList.add('open'); sugg.innerHTML = '';
      items.slice(0,8).forEach(m => {
        const row = document.createElement('div');
        row.className = 'suggestion';
        row.textContent = m.name || m.id;
        row.addEventListener('mousedown', (e)=>{
          e.preventDefault();
          const idU = String(m.id||'').toUpperCase();
          if (!selected.some(x => String(x.id||'').toUpperCase() === idU)) {
            selected.push({ id:idU, name: m.name || idU });
            renderChips();
          }
          input.value = ''; closeSuggestions();
        });
        sugg.appendChild(row);
      });
      if (!items.length) {
        const row = document.createElement('div');
        row.className = 'suggestion';
        row.style.color = '#98a2b3';
        row.textContent = 'No matches';
        sugg.appendChild(row);
      }
    }

    input.addEventListener('input', () => {
      const q = input.value.trim().toLowerCase();
      if (!q) return closeSuggestions();
      const matches = ALL_MENTORS
        .filter(m => (m.name||'').toLowerCase().includes(q) || (m.id||'').toLowerCase().includes(q))
        .filter(m => !selected.some(x => String(x.id||'').toUpperCase() === String(m.id||'').toUpperCase()));
      openSuggestions(matches);
    });
    input.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') { e.preventDefault(); const first = sugg.querySelector('.suggestion'); if (first) first.dispatchEvent(new Event('mousedown')); }
      if (e.key === 'Backspace' && !input.value && selected.length) { selected.pop(); renderChips(); }
      if (e.key === 'Escape') { closeSuggestions(); }
    });
    input.addEventListener('blur', () => setTimeout(closeSuggestions, 120));

    const pickerApi = {
      mergeMentors(list){
        mergeMentorList(list);
      },
      getSelection(){
        return selected.slice();
      }
    };
    noteEl._mentorPicker = pickerApi;

    mentorsReady.then(() => {
      if (pendingMerge.length) mergeMentorList(pendingMerge, false);
    });

    renderChips();
    return pickerApi;
  }

  // ---------- Render ----------
  function renderBoard(roster, prefillMap = {}){
    const board = document.getElementById('board');
    if (!board) return;
    board.innerHTML = '';

    const groups = Object.keys(roster || {});
    if (!groups.length) {
      board.classList.add('is-empty');
      const empty = document.createElement('div');
      empty.className = 'empty-state';
      empty.innerHTML = '<strong>No groups yet.</strong><br/>Try another date or confirm the roster has sign-ins.';
      board.appendChild(empty);
      setStatus('No groups with people for this date.', 'info');
      renderSummary({});
      return;
    }
    setStatus('');
    board.classList.remove('is-empty');
    renderSummary(roster);

    const known = GROUP_ORDER.filter(g => groups.includes(g));
    const unexpected = groups.filter(g => !GROUP_ORDER.includes(g));
    const order = [...known, ...unexpected];

    order.forEach(groupName => {
      const prefill = prefillMap[groupName] || {};
      prefillMap[groupName] = prefill;
      const noteData = prefill.note || null;
      const prefillMentors = Array.isArray(prefill.mentors) ? prefill.mentors : [];
      const col = document.createElement('div');
      col.className = 'group';
      col.dataset.group = groupName;
      const heading = document.createElement('h3');
      heading.textContent = groupName;
      const cardsWrap = document.createElement('div');
      cardsWrap.className = 'cards';
      col.appendChild(heading);
      col.appendChild(cardsWrap);

      col.addEventListener('dragover', onDragOver);
      col.addEventListener('dragleave', onDragLeave);
      col.addEventListener('drop', onDropGroup);

      const container = cardsWrap;

      // Cards
      (roster[groupName] || []).forEach(person => {
        const card = document.createElement('div');
        card.className = 'card';
        card.draggable = true;
        card.dataset.id = person.id;
        card.dataset.group = groupName;
        card.dataset.name = person.name;

        const status = computeStatus(person);
        const extra = [person.school, person.grade].filter(Boolean).join(' · ');

        const header = document.createElement('div');
        header.className = 'card-header';
        const titleWrap = document.createElement('div');
        titleWrap.className = 'card-title';
        const dot = document.createElement('span');
        dot.className = `status-dot ${status.color}`;
        dot.title = status.label;
        const nameSpan = document.createElement('span');
        nameSpan.className = 'name';
        nameSpan.textContent = person.name || person.id || 'Unknown';
        const idSpan = document.createElement('span');
        idSpan.className = 'muted id-span';
        idSpan.textContent = `(${person.id || '—'})`;
        titleWrap.appendChild(dot);
        titleWrap.appendChild(nameSpan);
        titleWrap.appendChild(idSpan);

        const menuBtn = document.createElement('button');
        menuBtn.type = 'button';
        menuBtn.className = 'menu-btn';
        menuBtn.title = 'Edit ID';
        menuBtn.setAttribute('aria-label', 'Edit ID');
        menuBtn.innerHTML = `
          <svg width="16" height="16" viewBox="0 0 24 24" aria-hidden="true">
            <circle cx="5" cy="12" r="2"></circle>
            <circle cx="12" cy="12" r="2"></circle>
            <circle cx="19" cy="12" r="2"></circle>
          </svg>
        `;
        header.appendChild(titleWrap);
        header.appendChild(menuBtn);

        card.appendChild(header);
        if (extra) {
          const extraEl = document.createElement('div');
          extraEl.className = 'muted';
          extraEl.textContent = extra;
          card.appendChild(extraEl);
        }

        card.addEventListener('dragstart', onDragStart);
        card.addEventListener('dragend', onDragEnd);

        card.addEventListener('click', (e) => {
          if (card._dragging) return;
          if (e.target.closest('.menu-btn')) return;
          openDetailModal(person, status);
        });

        menuBtn.addEventListener('mousedown', (e) => e.stopPropagation());
        menuBtn.addEventListener('click', (e) => { e.stopPropagation(); openEditIdModal(card); });

        container.appendChild(card);
      });

      // --- Note form ---
      const note = document.createElement('div');
      note.className = 'note-form';
      note.innerHTML = `
        <div class="note-mentors">
          <div class="chips"></div>
          <input type="text" class="mentor-input" placeholder="Add mentor…" autocomplete="off">
          <div class="suggestions"></div>
        </div>
        <div class="note-row">
          <input type="text" class="note-topic" placeholder="Topic">
          <input type="number" class="note-duration" placeholder="Duration (min)" min="0">
        </div>
        <div>
          <textarea class="note-summary" placeholder="Summary"></textarea>
        </div>
        <div class="note-actions">
          <span class="note-status">Up to date</span>
          <button type="button" class="note-save">Save Note</button>
        </div>
      `;
      col.appendChild(note);

      const mentorPicker = wireMentorPicker(note);
      const topicInput = note.querySelector('.note-topic');
      const summaryInput = note.querySelector('.note-summary');
      const durationInput = note.querySelector('.note-duration');
      const statusEl = note.querySelector('.note-status');

      if (noteData) {
        topicInput.value = noteData.topic || '';
        summaryInput.value = noteData.summary || '';
        durationInput.value = noteData.duration || '';
        statusEl.textContent = 'Up to date';
      } else {
        topicInput.value = '';
        summaryInput.value = '';
        durationInput.value = '';
        statusEl.textContent = 'No note yet';
      }

      if (prefillMentors.length) {
        mentorPicker?.mergeMentors(prefillMentors);
      }

      // ---------- Save handler (unified, no after-call chaining)
      const saveBtn = note.querySelector('.note-save');

      saveBtn.addEventListener('click', () => {
        const topic = topicInput.value.trim();
        const summary = summaryInput.value.trim();
        const duration = Number(durationInput.value || 0);

        // Gather participants from the visible cards in this column
        const participants = Array.from(container.querySelectorAll('.card'))
          .map(c => ({ id: c.dataset.id, name: c.dataset.name }))
          .filter(p => p.id);

        if (!participants.length) {
          setStatus(`No participants in ${groupName} to save.`, 'bad');
          return;
        }

        // Mentors selected in the chips
        const mentors = (note._selectedMentors || []).map(m => ({ id: m.id, name: m.name }));

        statusEl.textContent = 'Saving…';
        saveBtn.disabled = true;

        callServer('saveFullGroupNote', [
          document.getElementById('datePicker').value,
          groupName,
          topic,
          summary,
          duration,
          participants,
          mentors
        ])
          .then(res => {
            saveBtn.disabled = false;
            if (!res?.ok) {
              statusEl.textContent = 'Error';
              setStatus(res?.error || 'Could not save note.', 'bad');
              return;
            }
            const participantsAdded = Number(res.participantsAdded || participants.length || 0);
            const mentorsAdded = Number(res.mentorsAdded || mentors.length || 0);
            mentorPicker?.mergeMentors(mentors);
            statusEl.textContent = `Saved · ${participantsAdded} students · ${mentorsAdded} mentor${mentorsAdded === 1 ? '' : 's'}`;
            note.dataset.contactId = res.contactId || note.dataset.contactId || '';
            setStatus(`Saved ${groupName} — ${participantsAdded} participants, ${mentorsAdded} mentor${mentorsAdded === 1 ? '' : 's'}.`, 'ok');
            setTimeout(() => { statusEl.textContent = 'Up to date'; }, 1500);
            prefill.note = { topic, summary, duration };
            prefill.mentors = mentors.slice();
            prefill.contactId = res.contactId || prefill.contactId || null;
          })
          .catch(err => {
            statusEl.textContent = 'Error';
            saveBtn.disabled = false;
            setStatus('Server error: ' + (err?.message || err), 'bad');
          });
      });

      board.appendChild(col);
    });
  }

  // ---------- Edit ID modal ----------
  let currentEditCard = null;
  function openEditIdModal(card) {
    currentEditCard = card;
    const input = document.getElementById('editIdInput');
    input.value = card.dataset.id;
    document.getElementById('editIdModal').style.display = 'flex';
    setTimeout(() => input.select(), 0);
  }
  function closeEditIdModal() {
    document.getElementById('editIdModal').style.display = 'none';
    currentEditCard = null;
  }
  (function wireEditIdModal(){
    const modal = document.getElementById('editIdModal');
    if (!modal) return;
    const input = document.getElementById('editIdInput');
    const cancelBtn = document.getElementById('editIdCancel');
    const saveBtn = document.getElementById('editIdSave');

    cancelBtn?.addEventListener('click', closeEditIdModal);
    modal.addEventListener('click', (e) => { if (e.target === modal) closeEditIdModal(); });
    input?.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') { e.preventDefault(); closeEditIdModal(); }
      if (e.key === 'Enter')  { e.preventDefault(); saveBtn.click(); }
    });
    saveBtn?.addEventListener('click', () => {
      if (!currentEditCard) return;
      const oldId = currentEditCard.dataset.id;
      const group = currentEditCard.dataset.group;
      const dateStr = document.getElementById('datePicker').value;
      const newId = (document.getElementById('editIdInput').value || '').trim();
      if (!newId || newId === oldId) { closeEditIdModal(); return; }

      const idSpan = currentEditCard.querySelector('.id-span');
      idSpan.textContent = `(${newId})`;
      currentEditCard.dataset.id = newId;

      callServer('updateMemberId', [oldId, group, dateStr, newId])
        .then(res => {
          if (!res?.ok) {
            idSpan.textContent = `(${oldId})`;
            currentEditCard.dataset.id = oldId;
            setStatus(res?.error || 'Update failed.', 'bad');
          } else {
            setStatus('ID updated.', 'ok');
            loadBoard();
          }
        })
        .catch(err => {
          idSpan.textContent = `(${oldId})`;
          currentEditCard.dataset.id = oldId;
          setStatus('Server error: ' + (err?.message || err), 'bad');
        })
        .finally(() => closeEditIdModal());
    });
  })();

  // ---------- Single entry-point ----------
  async function loadBoard(){
    const input = document.getElementById('datePicker');
    if (input && !input.value) input.value = new Date().toISOString().slice(0,10);
    const dateStr = input ? input.value : new Date().toISOString().slice(0,10);

    setStatus('Loading…', 'info');
    renderSummary({});
    try {
      await ensureMentorsLoaded();                    // mentors first
      const roster = await getRosterByDateAsync(dateStr);
      const groups = Object.keys(roster || {});
      const prefillsRes = groups.length
        ? await callServer('getGroupPrefill', [dateStr, groups]).catch(() => ({ groups: {} }))
        : { groups: {} };
      const prefills = prefillsRes && typeof prefillsRes === 'object' && prefillsRes.groups ? prefillsRes.groups : {};
      renderBoard(roster, prefills);
    } catch (e) {
      console.error(e);
      setStatus('Load error: ' + (e?.message || e), 'bad');
    } finally {
      // Always clear "Loading…"
      if ((document.getElementById('status')?.textContent || '').includes('Loading')) {
        setStatus('');
      }
    }
  }

  // ---------- Boot (after DOM) ----------
  window.addEventListener('DOMContentLoaded', () => {
    const dateInput = document.getElementById('datePicker');
    if (dateInput && !dateInput.value) dateInput.value = new Date().toISOString().slice(0,10);
    document.getElementById('loadBtn')?.addEventListener('click', loadBoard);
    dateInput?.addEventListener('change', loadBoard);

    // First, verify Apps Script connectivity
    callServer('ping')
      .then(() => {
        loadBoard();
      })
      .catch(err => {
        setStatus('Cannot reach server (ping failed): ' + (err?.message || err), 'bad');
      });

    // watchdog
    setTimeout(() => {
      if ((document.getElementById('status')?.textContent || '').includes('Loading')) {
        setStatus('Still loading… check console and that UiScript is included.', 'bad');
      }
    }, 12000);
  });
})();
</script>
